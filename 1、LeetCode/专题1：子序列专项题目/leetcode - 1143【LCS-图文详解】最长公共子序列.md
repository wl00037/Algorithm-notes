
有字符串:   
str1 = "abcdefg"  
str2 = "acf"

求str1和str2的最长公共子序列

我们画一张二维数组表 DP

  |''| a | b | c | d | e | f | g |
 -|-|-|-|-|-|-|-|-|
''|(0,0)- 0|(0,1)- 0|(0,2)- 0|(0,3)- 0|(0,4)- 0|(0,5)- 0|(0,6)- 0|(0,7)- 0|
a |(1,0)- 0|(1,1)- 1|(1,2)- 1|(1,3)- 1|(1,4)- 1|(1,5)- 1|(1,6)- 1|(1,7)- 1|
c |(2,0)- 0|(2,1)- 1|(2,2)- 1|(2,3)- 2|(2,4)- 2|(2,5)- 2|(2,6)- 2|(2,7)- 2|
f |(3,0)- 0|(3,1)|(3,2)|(3,3)|(3,4)|(3,5)|(3,6)|(3,7)|


上图就是一个标准的二维数组，假设这个数组叫做 DP，这个二维数组每个元素DP[i][j]表示：str1[0:i] 与 str2[0:j] 两个字符串的最长公共子串；

比如DP[2][3]，这个元素的值就是：str1 = str1[0:3] = "abc" 与str2 = str2[0:2] = "ac" 这两个字符串的最长公共子序列，也就是2；



###### base case

DP[0][j] 和 DP[i][0] 均为0，其实按照上面的意思就是：假如str1在""阶段，那么str2取任意长度的子串，都不可能具有公共子序列(空字符串还哪有子序列的说法？)，反过来str2取""一个道理；

这些 “0” ，就是base case；

###### 本体解：就是要计算出DP[3][7]索引位上的值

所以，简单来说，这道题的解题过程就是把这个DP二维数组填完的过程；

整体来看，思路如下：  
1、str1[i]和str2[j]的每个字符都相互比较，以此来实现填写上述表的过程(for循环嵌套)；  
2、当str1[i] == str2[j]，说明此时lcs要增加1，这个地方就是<font color="red">第一个思维重点</font>：

	要从DP[i-1][j-1]的基础上增加1作为DP[i][j]的值；

	之所以这么做主要原因就是为了防止出现str1[i]和str2[j]以及str2[j-1]都相同的情况，所以只有用DP[i-1][j-1] 表示i和j同时加1后两个字符相同，lcs才加了1；
	
	比如如下：
			a	b	b
		a	1	1	1
		b	1	2	? -> 这个地方如果不用dp[i-1][j-1] + 1，就无法计算
		

3、当str1[i] != str2[j]，这个时候会出现本题的<font color="red">第二个思维重点</font>：
	
	其实我们要判断的，当str1[i] != str2[j]，那么DP[i][j]应该放什么？

	其实很简单：放max(DP[i-1][j],DP[i][j-1])；
	原因：要保证DP[i][j]永远是已经填写过的内容中最大的值，然而在i或者j加1之前最大的，不就是DP[i-1][j],DP[i][j-1]么？


通过上面的分析，代码就很简单了：

	def longestCommonSubsequence(self,str1,str2):
		len1 = len(str1)+1		#	+1 是为了保证base case
		len2 = len(str2)+1
		
		#	生成 dp table
		dp = [	[0]*len1 for i in range(len2)]
		
		for i in range(1,len1):
			for j in range(1,len2):
	
				if str1[i] == str2[j]:
					dp[i][j] = dp[i-1][j-1] + 1
				
				if str1[i] != str2[j]:
					dp[i][j] = max(dp[i-1][j],dp[i][j-1])
		
		return dp[len1-1][len2-1]


				