
有字符串:   
str1 = "abcdefg"  
str2 = "acf"

求str1和str2的最长公共子序列

我们画一张二维数组表 DP

  |''| a | b | c | d | e | f | g |
 -|-|-|-|-|-|-|-|-|
''|(0,0)- 0|(0,1)- 0|(0,2)- 0|(0,3)- 0|(0,4)- 0|(0,5)- 0|(0,6)- 0|(0,7)- 0|
a |(1,0)- 0|(1,1)- 1|(1,2)- 1|(1,3)- 1|(1,4)- 1|(1,5)- 1|(1,6)- 1|(1,7)- 1|
c |(2,0)- 0|(2,1)- 1|(2,2)- 1|(2,3)- 2|(2,4)- 2|(2,5)- 2|(2,6)- 2|(2,7)- 2|
f |(3,0)- 0|(3,1)|(3,2)|(3,3)|(3,4)|(3,5)|(3,6)|(3,7)|


上图就是一个标准的二维数组，假设这个数组叫做 DP，这个二维数组每个元素DP[i][j]表示：str1[0:i] 与 str2[0:j] 两个字符串的最长公共子串；

比如DP[2][3]，这个元素的值就是：str1 = str1[0:3] = "abc" 与str2 = str2[0:2] = "ac" 这两个字符串的最长公共子序列，也就是2；



###### base case

DP[0][j] 和 DP[i][0] 均为0，其实按照上面的意思就是：假如str1在""阶段，那么str2取任意长度的子串，都不可能具有公共子序列(空字符串还哪有子序列的说法？)，反过来str2取""一个道理；

这些 “0” ，就是base case；

###### 本体解：就是要计算出DP[3][7]索引位上的值

所以，简单来说，这道题的解题过程就是把这个DP二维数组填完的过程；


假如：我们要填：DP[2][3]的值，也就是说要计算 str1 = str1[0:3] = "abc" 与str2 = str2[0:2] = "ac" 的最长公共子序列，我们如何得到？ -> 这个其实就是本题解法中的转移方程；

